defmodule Projecttwo do
  def main(num_nodes, topology, algorithm) do
    if algorithm == "gossip" do
      IO.puts "gossip"
      message_limit = 10
      GossipFunction.createProcesses(String.to_integer(num_nodes), message_limit, String.to_integer(num_nodes))
      {:ok, server_pid} = GenServer.start_link(ServerNode, 0, name: :serverNode)
      :global.register_name(:servernode, server_pid)
      :global.sync()
      #IO.puts "Creating children"
      random_start_node = :rand.uniform(String.to_integer(num_nodes))
      IO.puts "Sending random process #{random_start_node} message"
      #IO.puts :global.whereis_name(:node1)
      GossipFunction.send_message(:global.whereis_name(:"node#{random_start_node}"))
    end
    if algorithm == "pushsum" do
      IO.puts "pushsum"
      PushSum.createProcesses(String.to_integer(num_nodes), String.to_integer(num_nodes), topology)
      {:ok, server_pid} = GenServer.start_link(ServerNode, [], name: :serverNode)
      :global.register_name(:servernode, server_pid)
      :global.sync()

      random_start_node = :rand.uniform(String.to_integer(num_nodes))
      IO.puts "Sending random process #{random_start_node} message"

      PushSum.send_message(:global.whereis_name(:"node#{random_start_node}"), 0, 0)
    end
    infiniteLoop()
  end

  def infiniteLoop do
    infiniteLoop()
  end
end

defmodule ServerNode do
  use GenServer
  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  def init(args) do
    {:ok, args}
  end

  def add_blacklist(pid, message) do
    GenServer.cast(pid, {:add_blacklist, message})
  end

  def get_blacklist(pid) do
    GenServer.call(pid, :get_blacklist, :infinity)
  end

  def get_whitelist(pid, nodeId, topo, numNodes) do
    GenServer.call(pid, {:get_whitelist, nodeId, topo, numNodes}, :infinity)
  end

  def handle_call({:get_neighbours, neighbours}, _from, state) do
    #ret_val = neighbours -- state
    #IO.puts "neighbours is #{List.first(neighbours)}"
    neighbours = Enum.filter(neighbours, fn el -> !Enum.member?(state, el) end)
    #IO.puts "neighbours is #{List.first(neighbours)}"

    rnd_neigh = []
    rnd_neigh =
    if Kernel.length(neighbours) >= 1 do
      rnd_num = :rand.uniform(Kernel.length(neighbours))
      rnd_neigh ++ [Enum.at(neighbours, rnd_num - 1)]
    else
      []
    end
    {:reply, rnd_neigh, state}
  end

  #def handle_call({:get_whitelist, nodeId, topo, numNodes}, _from, messages) do
  #  nodernd = whiteRandom(topo, numNodes, nodeId, messages)
  #  {:reply, nodernd, messages}
  #end

  def handle_cast({:add_blacklist, new_message}, messages) do
    IO.puts "Node added: #{new_message}"
    {:noreply, [new_message | messages]}
  end

  #wait for all done messages and then exit
  def handle_cast(:done_dummy, state) do
    if state == 10 do
      :ok
      #Process.exit(self(), :kill)
    end
    IO.puts "Server state is #{state+1}"
    {:noreply, state + 1}
  end

  def get_neighbours(pid, nodeId) do
    #IO.puts "Hello #{nodeId}"
    #IO.inspect pid
    GenServer.call(pid , {:get_neighbours, nodeId})
  end
end

defmodule SpamMessage do
  use GenServer
  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  def init(args) do
    {:ok, args}
  end

  def parent_start_cast(pid) do
    GenServer.cast(pid, {:spam_message})
  end

  def push_sum_start_cast(pid, s, w) do
    GenServer.cast(pid, {:push_sum_message, s, w})
    #send pid,{:push_sum_message, s, w}
  end

  def parent_stop_cast(pid) do
    GenServer.cast(pid, {:stop_spam})
  end

  def send_message(pid) do
    GenServer.cast(pid, {:spam_message})
  end

  def handle_cast({:spam_message}, state) do
    neighbour = get_random(state)
    #IO.puts "My neighbour is #{neighbour}"
    GenServer.cast(:global.whereis_name(String.to_atom(neighbour)), {:send_message})
    #send_message(:global.whereis_name(String.to_atom(neighbour)))
    GenServer.cast(self(), {:spam_message})

    {:noreply, state}
  end

  def handle_cast({:push_sum_message, s, w}, state) do
    neighbour = get_random(state)
    #IO.puts "My neighbour is #{neighbour}"
    GenServer.cast(:global.whereis_name(String.to_atom(neighbour)), {:push_sum_send_message, s, w})
    #send_message(:global.whereis_name(String.to_atom(neighbour)))
    #GenServer.cast(self(), {:push_sum_message, s, w})

    {:noreply, state}
  end

  def handle_cast({:stop_spam}, state) do
    #IO.puts "Stopping spam"
    Process.exit(self(),:normal)
    {:shutdown, state}
  end

  def handle_info({:push_sum_send_message, s, w}, state) do
    IO.puts "Info"
    neighbour = get_random(state)
    GenServer.cast(:global.whereis_name(String.to_atom(neighbour)), {:push_sum_send_message, s, w})
    dummy()
    {:noreply, state}
  end

  def dummy do
    Process.send_after(self(), :push_sum_send_message, 2 * 1000) # In 2 seconds
  end
  def get_random(state) do
    if Kernel.length(state) > 1 do
      rnd_neighbour = :rand.uniform(Kernel.length(state))
      Enum.at(state, rnd_neighbour - 1)
    else
      Enum.at(state, 0)
    end
  end
end

defmodule GossipFunction do
  use GenServer

  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  def init(arg) do
    {:ok, arg}
  end

  def get_random(state) do
    if Kernel.length(Map.get(state, :neighbourList)) > 1 do
      rnd_neighbour = :rand.uniform(Kernel.length(Map.get(state, :neighbourList)))
      Enum.at(Map.get(state, :neighbourList), rnd_neighbour - 1)
    else
      Enum.at(Map.get(state, :neighbourList), 0)
    end
  end

  def send_message(pid) do
    GenServer.cast(pid, {:send_message})
  end

  def myProg(state) when is_list(state) do
    IO.puts "I am a list"
  end

  def handle_cast({:send_message}, state) do
    #IO.puts "NodeId: #{nodeId}"
    if Map.get(state, :curr_state) == Map.get(state, :message_limit) do
      {:noreply, state}
    else
      #neighbours = get_random(state)
      #IO.puts "#{Map.get(state, :nodeId)}: My neighbour is #{neighbours}"
      #myProg(neighbours)
      #GossipFunction.send_message(:global.whereis_name(String.to_atom(neighbours)))
      if Map.get(state, :curr_state) == 0 do
        SpamMessage.parent_start_cast(Map.get(state, :sender_pid))
      end

      {_, state} = Map.get_and_update(state, :curr_state, fn(x) -> {x, (x || 0) + 1} end)

      #IO.puts "#{Map.get(state, :nodeId)}: New state #{Map.get(state, :curr_state)}"
      curr_state = Map.get(state, :curr_state)
      if curr_state == Map.get(state, :message_limit) do
        IO.puts "Process #{Map.get(state, :nodeId)} is done."
        SpamMessage.parent_stop_cast(Map.get(state, :sender_pid))
        #GenServer.cast(:global.whereis_name(:servernode), :done)
      end
      #{_, state} = Map.get_and_update(state, :curr_state, fn(x) -> {x, (x || 0) + 1} end)
      {:noreply, state}
    end
  end

  def createProcesses(num_processes, message_limit, total_nodes) do
    if num_processes > 0 do
      temps = Topology.select_topology("full", total_nodes, num_processes)

      neighbours = Enum.map(temps, fn(x) -> "node#{x}" end)
      {:ok, send_pid} = GenServer.start_link(SpamMessage, neighbours, name: String.to_atom("sender#{num_processes}"))

      {:ok, pid} = GenServer.start_link(GossipFunction,
        %{curr_state: 0, nodeId: num_processes, neighbourList: neighbours, message_limit: message_limit, sender_pid: send_pid},
        name: String.to_atom("node#{num_processes}"))
      :global.register_name(String.to_atom("node#{num_processes}"), pid)

      createProcesses(num_processes - 1, message_limit, total_nodes)
    end

  end
end

defmodule PushSum do
  use GenServer

  def start_link do
    GenServer.start_link(__MODULE__, [])
  end

  def init(args) do
    {:ok, args}
  end

  def handle_cast({:push_sum_send_message, input_s, input_w}, state) do
    if Enum.at(state, 4) == 3 do
      IO.puts "Stop spamming me!"
      {:noreply, state}
    end
    old_s = Enum.at(state, 1)
    old_w = Enum.at(state, 2)

    old_ratio = old_s / old_w

    new_ratio = (Enum.at(state, 1) + input_s) / ( Enum.at(state, 2) + input_w)

    new_s = (Enum.at(state, 1) + input_s) / 2
    new_w = (Enum.at(state, 2) + input_w) / 2

    new_sc =
    if Kernel.abs(old_ratio - new_ratio) < 0.0000000001 do
      Enum.at(state, 4) + 1
    else
      0
    end
    #IO.puts "#{Enum.at(state, 3)}: saturation is #{new_sc}"

    if new_sc >= 3 do
      IO.puts "#{Enum.at(state, 3)}: Done"
      ServerNode.add_blacklist(:global.whereis_name(:servernode), "node#{Enum.at(state, 3)}")
      #Process.exit(self(), :normal)
      #GenServer.cast(:global.whereis_name(:servernode), :done)
    end

    neigh = GenServer.call(:global.whereis_name(:servernode), {:get_neighbours, Enum.at(state, 6)})
    #IO.puts neigh
    #IO.puts "#{Enum.at(state, 3)}: #{List.first(neigh)}"
    if Kernel.length(neigh) == 0 do
      IO.puts "No neighbours"
      ServerNode.add_blacklist(:global.whereis_name(:servernode), "node#{Enum.at(state, 3)}")
      #Process.exit(self(), :normal)
    else
      GenServer.cast(:global.whereis_name(String.to_atom(List.first(neigh))), {:push_sum_send_message, new_s, new_w})
    end

    new_active =
    if Enum.at(state, 5) == 0 do
      1
    end

    new_state = [Enum.at(state, 0), new_s, new_w, Enum.at(state, 3), new_sc, new_active, Enum.at(state, 6)]
    {:noreply, new_state}
  end

  def send_message(pid, s, w) do
    GenServer.cast(pid, {:push_sum_send_message, s, w})
  end

  def createProcesses(num_processes, total_nodes, topology) do
    if num_processes > 0 do
      #neighbours = Topology.get_neighbours(num_processes, total_nodes)
      temps = Topology.select_topology(topology, total_nodes, num_processes)

      neighbours = Enum.map(temps, fn(x) -> "node#{x}" end)

      {:ok, send_pid} = GenServer.start_link(SpamMessage, neighbours, name: String.to_atom("sender#{num_processes}"))

      {:ok, pid} = GenServer.start_link(PushSum,
        [send_pid, num_processes, 1, num_processes, 0, 0, neighbours],
        name: String.to_atom("node#{num_processes}"))
      :global.register_name(String.to_atom("node#{num_processes}"), pid)
      createProcesses(num_processes - 1, total_nodes, topology)
    end
  end
end
